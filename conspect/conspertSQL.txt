**** CREATE TABLE Person(
        id int,
        name varchar,
        age int,
        email varchar
     ) -- создать таблицу с такими полями

**** insert into person() values (1,'Tom',18,'tom@mail.ru') -- добавляет данные в колонки,
если данные добавляются во все колонки то передается просто название таблицы без скобок

**** select * from person -- выводит все значения таблицы
// удаление данных из таблицы
**** TRUNCATE TABLE person;

// изменение одного поле данных
UPDATE person set role='ROLE_ADMIN' WHERE id=7
// генерация Id

**** create sequence first_sequence -- создает поле для генерации значения с названием first_sequence

**** select nextval('first_sequence') -- вызывает наше поле и присвоит ему значение, при повторном вызове
увеличивает значение на единицу

**** drop sequence first_sequence -- удаление поле с генерацией значения

// создаем новую таблицу Person
create table Person(
    id SERIAL,  -- значение которое позволяет генерировать значения из созданного нами генератора значений
       ( id int GENERATED ALWAYS AS IDENTITY) -- второй способ который используется в стандарте после 10 версии
    name varchar,
    age int,
    email varchar
)

// валидация на стороне БД

create table Person(
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- значение которое позволяет генерировать значения из созданого нами гениратора значений
PRIMARY KEY (помечает колонку как первичный ключ)
    name varchar NOT NULL , -- проверяет что значение не равно null
    age int check ( age>0 ), -- значение не должно быть меньше 0
    email varchar UNIQUE -- значение должно быть уникальным и не должно повторяться
)

// временное объединение таблиц по первичному ключу и внешнему ключу

1. inner Join

SELECT * FROM Person JOIN Order ON Person.user_id = Order.user_id

    Person.user_id -- первичный ключ
    Order.user_id -- внешний ключ

    сопоставляет две таблицы (Person и Order) в одну и выводит значения из первой таблицы
    который были указа во второй, если значение не было указано то не будет выводить

2. Outer Join (Left)

SELECT * FROM Person LEFT JOIN Order ON Person.user_id = Order.user_id

    сопоставляет все данные из левой таблице с таблицей из правой части и выводит
    их в одну единую таблицу, если значение не было указанно то выведет значение
    из первой таблицы а из второй укажет как null

3. Outer Join (Right)

SELECT * FROM Person RIGHT JOIN Order ON Person.user_id = Order.user_id

    то же самое что и Outer Join (Left) только сопоставление будет проводиться из 2 таблице

4. Cross Join

SELECT * FROM Person CROSS JOIN Order

 выводит таблицу сопоставления всех колонок из первой таблице со второй
 CREATE TABLE Movie(
     movie_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY ,
     director_id int NOT NULL REFERENCES director(director_id), -- помечает эту колонку как внешний ключ
 и передает туда значения из таблицы 1 в таблицу 2
     name varchar(200) NOT NULL ,
     year_of_productio int CHECK (year_of_productio > 1900 )
 )

 SELECT director.name, Movie.name  FROM director JOIN movie on director.director_id = movie.director_id
сопоставление двух колонок name  на основании совпадения значений id

CREATE TABLE Actor_Movie(
    actor_id int REFERENCES Actor(actor_id), -- связываем с 1 таблицей
    movie_id int REFERENCES Movie(movie_id), -- связываем со второй таблицей
    PRIMARY KEY(actor_id, movie_id)
);

SELECT Actor.name, Movie.name FROM Actor JOIN actor_movie ON actor.actor_id = actor_movie.actor_id JOIN movie ON actor_movie.movie_id = movie.movie_id;

выводим отношение многим ко многим

// индексирование таблицы(для сортировки по значению)
CREATE INDEX ON citizen(name) USING ???

CREATE INDEX -- создать индекс
ON citizen(name) -- для таблицы citizen для поля name
USING ??? -- тип индекса

// каскадирование(удаление из таблицы данных с первичным и внешним ключом)
 *** при создании таблицы мы должны прописать что будет если удалить данные из
 первичного ключа который ссылается на внешний ключ

        create table "order"(
            order_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY ,
            user_id int REFERENCES Person (user_id) ON DELETE CASCADE ,
            item_name varchar(100)
        );

user_id int REFERENCES Person(user_id) ON DELETE ???
    user_id -- внешний ключ
    REFERENCES Person(user_id) -- ссылка на первичный ключ
    ON DELETE ??? -- команда для удаления

??? --
    -- CASCADE -- удаляет строки в зависимой таблице при удалении связанных
строк в главной таблице (удаление человека -> удаление всех его заказов)

    -- SET NULL -- выставляет значение внешнего ключа равного Null при удалении
связанные строк в главной таблице (удаление человека -> в его заказах будет числиться Null)

    -- RESTRICT -- поведение по умолчанию (выдает ошибку при удалении так как
ключ ссылается на внешний ключ)

DELETE FROM person WHERE user_id=1 -- удаляет человека с первичным ключом 1

// удаление данных из таблицы
TRUNCATE TABLE person -- очистить таблицу от данных
ALTER TABLE person DROP COLUMN mood -- удалить колонку из таблице
ALTER TABLE person ADD COLUMN address varchar NOT NULL -- добавление новой колонки address

------------------------------------ Дата ----------------------------------------------------
--- Просто дата без точного времени

ALTER TABLE person ADD COLUMN data_of_birth DATE;

--- Точное время
--- Значение timestamp сохраняются в секундах до или после 1 января 2000г.

ALTER TABLE person ADD COLUMN created_at timestamp;

------------------------------------ Enum ----------------------------------------------------
ALTER TABLE person add COLUMN mood int -- потому что выбрали параметр EnumType.ORDINAL
alter table person add column mood varchar(100); -- потому что  выбрали EnumType.STRING